Skip to content
Chat history

You said:
# -*- coding: utf-8 -*-
from odoo import http
from odoo.http import request

class InventoryDashboardController(http.Controller):

    @http.route('/inventory/dashboard/data', type='json', auth='user')
    def get_data(self, filters=None):
        if filters is None:
            filters = {}
        return request.env['inventory.dashboard'].get_dashboard_data(filters)# -*- coding: utf-8 -*-
from odoo import models, api
from datetime import date, timedelta, datetime
from dateutil.relativedelta import relativedelta


class InventoryDashboard(models.Model):
    _name = "inventory.dashboard"
    _description = "Inventory Dashboard Data"

    def _get_date_domain(self, period, value=None):
        """
        Helper function to generate a date domain.
        It now handles specific week, month, or year values.
        """
        domain = []
        if not period or period == 'all' or not value:
            return []

        try:
            if period == 'week':

                start_date = datetime.strptime(f"{value}-1", "%Y-W%W-%w").date()
                end_date = start_date + timedelta(days=6)
                domain = [('date', '>=', start_date), ('date', '<=', end_date)]
            elif period == 'month':
                year, month = map(int, value.split('-'))
                start_date = date(year, month, 1)
                end_date = (start_date + relativedelta(months=1)) - timedelta(days=1)
                domain = [('date', '>=', start_date), ('date', '<=', end_date)]
            elif period == 'year':
                year = int(value)
                start_date = date(year, 1, 1)
                end_date = date(year, 12, 31)
                domain = [('date', '>=', start_date), ('date', '<=', end_date)]
        except (ValueError, TypeError):
            return []

        return domain

    @api.model
    def get_dashboard_data(self, filters=None):
        """
        Fetch inventory dashboard data.
        This function now applies date filters based on specific user input.
        """
        if filters is None:
            filters = {}

        data = {}
        period = filters.get('period')
        value = filters.get('value')
        date_domain = self._get_date_domain(period, value)

        incoming_domain = date_domain + [('picking_code', '=', 'incoming')]
        data['incoming'] = self.env['stock.move'].read_group(
            incoming_domain, ['product_id', 'product_uom_qty:sum'], ['product_id']
        )

        outgoing_domain = date_domain + [('picking_code', '=', 'outgoing')]
        data['outgoing'] = self.env['stock.move'].read_group(
            outgoing_domain, ['product_id', 'product_uom_qty:sum'], ['product_id']
        )

        internal_domain = date_domain + [('picking_code', '=', 'internal')]
        data['internal'] = self.env['stock.move'].read_group(
            internal_domain, ['product_id', 'product_uom_qty:sum'], ['product_id']
        )

        data['location_stock'] = self.env['stock.quant'].read_group(
            [], ['location_id', 'quantity:sum'], ['location_id']
        )


        picking_date_domain = [(item[0].replace('date', 'date_done'), item[1], item[2]) for item in date_domain]
        data['picking_types'] = self.env['stock.picking'].read_group(
            picking_date_domain, ['picking_type_id'], ['picking_type_id']
        )

        warehouses = self.env['stock.warehouse'].search([])
        data['warehouses'] = [{'name': wh.name, 'code': wh.code} for wh in warehouses]

        quants = self.env['stock.quant'].read_group([], ['quantity:sum', 'value:sum'], ['location_id'])
        valuation_data = []
        for q in quants:
            if q['location_id']:
                location_id = q['location_id'][0]
                location = self.env['stock.location'].browse(location_id)
                if location.usage == 'internal':
                    value_number = round(q.get('value', 0), 2)
                    valuation_data.append({
                        'warehouse': location.display_name,
                        'value': value_number
                    })
        data['inventory_valuation'] = valuation_data

        products = self.env['product.product'].search([('purchase_ok', '=', True)])
        avg_expense_data = []

        purchase_date_domain = []
        if date_domain:
            purchase_date_domain = [('order_id.date_order', item[1], item[2]) for item in date_domain]

        for product in products:
            purchase_lines = self.env['purchase.order.line'].search(
                [('product_id', '=', product.id)] + purchase_date_domain
            )
            total_cost = 0
            total_qty = 0

            for line in purchase_lines:
                purchase_cost = line.price_unit or 0
                qty = line.product_qty or 1

                landed_lines = self.env['stock.landed.cost.lines'].search([('product_id', '=', product.id)])
                landed_cost = sum(lc.price_unit for lc in landed_lines)

                total_cost += (purchase_cost + landed_cost) * qty
                total_qty += qty

            average_expense = total_cost / total_qty if total_qty else 0

            if total_qty > 0:
                avg_expense_data.append({
                    'product': product.name,
                    'average_expense': round(average_expense, 2)
                })

        data['average_expense'] = avg_expense_data

        return data/** @odoo-module **/
import { registry } from "@web/core/registry";
import { Component, onWillStart, useState, onMounted } from "@odoo/owl";
import { rpc } from "@web/core/network/rpc";
import { loadJS } from "@web/core/assets";

class InventoryDashboard extends Component {
    setup() {
        const currentYear = new Date().getFullYear();

        this.state = useState({
            data: {},
            filterType: 'all',
            selectedWeek: '',
            selectedMonth: '',
//            selectedYear: currentYear.toString(),
            activeFilterDisplay: 'All Time',
        });
        this.charts = {};

        onWillStart(async () => {
            if (typeof Chart === "undefined") {
                await loadJS("https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js");
            }
            await this.fetchData();
        });

        onMounted(() => {
            this.renderCharts();
        });
    }

    async fetchData() {
        let filters = { period: this.state.filterType };
        if (this.state.filterType === 'week' && this.state.selectedWeek) {
            filters.value = this.state.selectedWeek;
        } else if (this.state.filterType === 'month' && this.state.selectedMonth) {
            filters.value = this.state.selectedMonth;
        }

        this.state.data = await rpc("/inventory/dashboard/data", { filters });

        if (this.charts.incomingChart) {
             this.renderCharts();
        }
    }

    onWeekChange(ev) {
        this.state.selectedWeek = ev.target.value;
        this.state.filterType = 'week';
        this.state.activeFilterDisplay = Week: ${this.state.selectedWeek};
        this.fetchData();
    }

    onMonthChange(ev) {
        this.state.selectedMonth = ev.target.value;
        this.state.filterType = 'month';
        const date = new Date(this.state.selectedMonth + '-02');
        const monthName = date.toLocaleString('default', { month: 'long' });
        const year = date.getFullYear();
        this.state.activeFilterDisplay = Month: ${monthName} ${year};
        this.fetchData();
    }



    async clearFilters() {
        this.state.filterType = 'all';
        this.state.selectedWeek = '';
        this.state.selectedMonth = '';
//        this.state.selectedYear = new Date().getFullYear().toString();
        this.state.activeFilterDisplay = 'All Time';
        await this.fetchData();
    }

    destroyCharts() {
        for (const chartKey in this.charts) {
            if (this.charts[chartKey]) {
                this.charts[chartKey].destroy();
            }
        }
        this.charts = {};
    }

    renderCharts() {
        this.destroyCharts();
        const data = this.state.data;

        if (data.incoming) {
            const ctx = document.getElementById("incomingChart");
            if (ctx) {
                this.charts.incomingChart = new Chart(ctx, {
                    type: "bar",
                    data: {
                        labels: data.incoming.map(i => i.product_id[1]),
                        datasets: [{
                            label: "Incoming Stock",
                            data: data.incoming.map(i => i.product_uom_qty),
                            backgroundColor: "rgba(54, 162, 235, 0.6)"
                        }]
                    },
                    options: { responsive: true, maintainAspectRatio: false }
                });
            }
        }

        if (data.outgoing) {
            const ctx = document.getElementById("outgoingChart");
            if (ctx) {
                this.charts.outgoingChart = new Chart(ctx, {
                    type: "bar",
                    data: {
                        labels: data.outgoing.map(i => i.product_id[1]),
                        datasets: [{
                            label: "Outgoing Stock",
                            data: data.outgoing.map(i => i.product_uom_qty),
                            backgroundColor: "rgba(255, 99, 132, 0.6)"
                        }]
                    },
                    options: { responsive: true, maintainAspectRatio: false }
                });
            }
        }

        if (data.location_stock) {
            const ctx = document.getElementById('locationChart');
            if (ctx) {
                this.charts.locationChart = new Chart(ctx, {
                    type: 'pie',
                    data: {
                        labels: data.location_stock.map(l => l.location_id[1]),
                        datasets: [{
                            data: data.location_stock.map(l => l.quantity),
                            backgroundColor: ['#36A2EB', '#FF6384', '#FFCE56', '#4BC0C0', '#9966FF'],
                        }]
                    },
                    options: { responsive: true, maintainAspectRatio: false }
                });
            }
        }

        if (data.picking_types) {
            const ctx = document.getElementById('pickingTypeChart');
            if (ctx) {
                this.charts.pickingTypeChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: data.picking_types.map(p => p.picking_type_id[1]),
                        datasets: [{
                            label: 'Pickings',
                            data: data.picking_types.map(p => p.picking_type_id_count || 0),
                            backgroundColor: 'rgba(153, 102, 255, 0.6)',
                        }]
                    },
                    options: { responsive: true, maintainAspectRatio: false }
                });
            }
        }

        if (data.internal) {
            const ctx = document.getElementById('internalTransferChart');
            if (ctx) {
                this.charts.internalTransferChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: data.internal.map(i => i.product_id[1]),
                        datasets: [{
                            label: 'Internal Transfers',
                            data: data.internal.map(i => i.product_uom_qty),
                            backgroundColor: 'rgba(255, 159, 64, 0.6)',
                        }]
                    },
                    options: { responsive: true, maintainAspectRatio: false }
                });
            }
        }

        if (data.warehouses) {
            const ctx = document.getElementById('warehouseChart');
            if (ctx) {
                const warehouseCounts = {};
                (data.location_stock || []).forEach(loc => {
                    const whName = loc.location_id[1].split('/')[0];
                    warehouseCounts[whName] = (warehouseCounts[whName] || 0) + loc.quantity;
                });
                const labels = Object.keys(warehouseCounts);
                const values = Object.values(warehouseCounts);

                this.charts.warehouseChart = new Chart(ctx, {
                    type: 'pie',
                    data: {
                        labels: labels,
                        datasets: [{
                            data: values,
                            backgroundColor: ['#4BC0C0', '#9966FF', '#FFCE56', '#36A2EB', '#FF6384'],
                        }]
                    },
                    options: { responsive: true, maintainAspectRatio: false }
                });
            }
        }

        if (data.inventory_valuation) {
            const ctxValuation = document.getElementById('valuationChart');
             if(ctxValuation) {
                this.charts.valuationChart = new Chart(ctxValuation, {
                    type: 'doughnut',
                    data: {
                        labels: data.inventory_valuation.map(v => v.warehouse),
                        datasets: [{
                            label: 'Inventory Value',
                            data: data.inventory_valuation.map(v => v.value),
                            backgroundColor: ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0'],
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: { legend: { position: 'bottom' } }
                    }
                });
             }
        }

        if (data.average_expense) {
            const ctx = document.getElementById('averageExpenseChart');
            if (ctx) {
                this.charts.averageExpenseChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: data.average_expense.map(p => p.product),
                        datasets: [{
                            label: 'Average Expense',
                            data: data.average_expense.map(p => p.average_expense),
                            backgroundColor: 'rgba(52, 152, 219, 0.6)',
                        }]
                    },
                    options: { responsive: true, maintainAspectRatio: false }
                });
            }
        }
    }
}

InventoryDashboard.template = "inventory_dashboard.InventoryDashboard";
registry.category("actions").add("inventory_dashboard_tag", InventoryDashboard);<?xml version="1.0" encoding="UTF-8" ?>
<templates>
    <t t-name="inventory_dashboard.InventoryDashboard" owl="1">
        <div class="o_container" style="background-color:#f8f9fa; font-family: 'Poppins', sans-serif;">
            <div class="p-3 mb-3 bg-white shadow-sm" style="border-radius:10px;">
                <div class="d-flex justify-content-between align-items-center mb-3">
                     <h2 style="color:#34495e; font-weight:600;">Inventory Overview</h2>
                     <h4 style="color:#555; font-weight:500;">
                        Period: <span class="text-primary" t-esc="state.activeFilterDisplay"/>
                     </h4>
                </div>

                <div class="d-flex flex-wrap align-items-end gap-3">
                    <div class="d-flex flex-column">
                        <label for="week-picker" class="form-label mb-1">Filter by Week</label>
                        <div class="input-group">
                            <input type="week" id="week-picker" class="form-control" t-att-value="state.selectedWeek" t-on-change="onWeekChange"/>
                        </div>
                    </div>

                    <div class="d-flex flex-column">
                        <label for="month-picker" class="form-label mb-1">Filter by Month</label>
                        <div class="input-group">
                            <input type="month" id="month-picker" class="form-control" t-att-value="state.selectedMonth" t-on-change="onMonthChange"/>
                        </div>
                    </div>

<!--                    <div class="d-flex flex-column">-->
<!--                        <label for="year-picker" class="form-label mb-1">Filter by Year</label>-->
<!--                        <div class="input-group">-->
<!--                            <input type="number" id="year-picker" class="form-control" placeholder="YYYY" t-att-value="state.selectedYear" t-on-change="onYearChange" style="min-width: 100px;"/>-->
<!--                        </div>-->
<!--                    </div>-->

                    <div class="ms-auto">
                        <button class="btn btn-outline-secondary" t-on-click="clearFilters">Show All Time</button>
                    </div>
                </div>
            </div>

            <div style="overflow-y:auto; max-height:calc(100vh - 160px); padding:10px; display:flex; flex-wrap:wrap; gap:20px; justify-content:center;">
                <div class="shadow-sm" style="background:#fff; border:1px solid #ddd; border-radius:10px; padding:15px; width:48%; min-width:300px;">
                    <h3 style="text-align:center; margin-bottom:10px; color:#34495e;">Incoming Stock</h3>
                    <div style="position:relative; height:250px;">
                        <canvas id="incomingChart"></canvas>
                    </div>
                </div>

                <div class="shadow-sm" style="background:#fff; border:1px solid #ddd; border-radius:10px; padding:15px; width:48%; min-width:300px;">
                    <h3 style="text-align:center; margin-bottom:10px; color:#34495e;">Outgoing Stock</h3>
                    <div style="position:relative; height:250px;">
                        <canvas id="outgoingChart"></canvas>
                    </div>
                </div>

                <div class="shadow-sm" style="background:#fff; border:1px solid #ddd; border-radius:10px; padding:15px; width:48%; min-width:300px;">
                    <h3 style="text-align:center; margin-bottom:10px; color:#34495e;">Current Stock by Location</h3>
                    <div style="position:relative; height:300px;">
                        <canvas id="locationChart"></canvas>
                    </div>
                </div>

                <div class="shadow-sm" style="background:#fff; border:1px solid #ddd; border-radius:10px; padding:15px; width:48%; min-width:300px;">
                    <h3 style="text-align:center; margin-bottom:10px; color:#34495e;">Picking Operations</h3>
                    <div style="position:relative; height:300px;">
                        <canvas id="pickingTypeChart"></canvas>
                    </div>
                </div>

                <div class="shadow-sm" style="background:#fff; border:1px solid #ddd; border-radius:10px; padding:15px; width:48%; min-width:300px;">
                    <h3 style="text-align:center; margin-bottom:10px; color:#34495e;">Internal Transfers</h3>
                    <div style="position:relative; height:300px;">
                        <canvas id="internalTransferChart"></canvas>
                    </div>
                </div>

                <div class="shadow-sm" style="background:#fff; border:1px solid #ddd; border-radius:10px; padding:15px; width:48%; min-width:300px;">
                    <h3 style="text-align:center; margin-bottom:10px; color:#34495e;">Stock by Warehouse</h3>
                    <div style="position:relative; height:300px;">
                        <canvas id="warehouseChart"></canvas>
                    </div>
                </div>

                <div class="shadow-sm" style="background:#fff; border:1px solid #ddd; border-radius:10px; padding:15px; width:48%; min-width:300px;">
                    <h3 style="text-align:center; margin-bottom:10px; color:#34495e;">Inventory Valuation</h3>
                    <div style="position:relative; height:350px;">
                        <canvas id="valuationChart"></canvas>
                    </div>
                </div>

                <div class="shadow-sm" style="background:#fff; border:1px solid #ddd; border-radius:10px; padding:15px; width:48%; min-width:300px;">
                    <h3 style="text-align:center; margin-bottom:10px; color:#34495e;">Average Expense (by Period)</h3>
                    <div style="position:relative; height:350px;">
                        <canvas id="averageExpenseChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </t>
</templates>User - Only his/her transfers

Manager - Complete transfers
ChatGPT said:
Got it ‚úÖ You want to restrict data visibility in your Inventory Dashboard so that:

User (Employee) ‚Üí Sees only his/her own transfers.

Manager (or Admin) ‚Üí Sees all transfers.

This is a classic case of record rule filtering based on user groups in Odoo.
You can handle it in two ways:

üîπ 1. Handle in Python (get_dashboard_data)
Modify your domain building for stock.move and stock.picking depending on the user‚Äôs groups:

from odoo import models, api

class InventoryDashboard(models.Model):
    _name = "inventory.dashboard"
    _description = "Inventory Dashboard Data"

    @api.model
    def get_dashboard_data(self, filters=None):
        if filters is None:
            filters = {}

        data = {}
        period = filters.get('period')
        value = filters.get('value')
        date_domain = self._get_date_domain(period, value)

        # -------------------------
        # Restrict data visibility
        # -------------------------
        user = self.env.user
        user_domain = []
        if not user.has_group('stock.group_stock_manager'):  # Not Manager
            user_domain = [('create_uid', '=', user.id)]  # Only own transfers

        # Apply restriction
        incoming_domain = date_domain + [('picking_code', '=', 'incoming')] + user_domain
        outgoing_domain = date_domain + [('picking_code', '=', 'outgoing')] + user_domain
        internal_domain = date_domain + [('picking_code', '=', 'internal')] + user_domain

        data['incoming'] = self.env['stock.move'].read_group(
            incoming_domain, ['product_id', 'product_uom_qty:sum'], ['product_id']
        )
        data['outgoing'] = self.env['stock.move'].read_group(
            outgoing_domain, ['product_id', 'product_uom_qty:sum'], ['product_id']
        )
        data['internal'] = self.env['stock.move'].read_group(
            internal_domain, ['product_id', 'product_uom_qty:sum'], ['product_id']
        )

        # Picking types visibility
        picking_date_domain = [(item[0].replace('date', 'date_done'), item[1], item[2]) for item in date_domain]
        picking_date_domain += user_domain
        data['picking_types'] = self.env['stock.picking'].read_group(
            picking_date_domain, ['picking_type_id'], ['picking_type_id']
        )

        # (rest of your code unchanged for warehouses, valuation, etc.)
        return data
üëâ This way:

Managers see everything.

Users only see their transfers (create_uid = user.id).

üîπ 2. Record Rules (cleaner, Odoo-native way)
You can create record rules on stock.move and stock.picking models:

For Inventory Manager (stock.group_stock_manager) ‚Üí No restriction.

For Regular Users (stock.group_stock_user) ‚Üí Add a rule:

<record id="stock_move_user_rule" model="ir.rule">
    <field name="name">User Own Stock Moves</field>
    <field name="model_id" ref="stock.model_stock_move"/>
    <field name="groups" eval="[(4, ref('stock.group_stock_user'))]"/>
    <field name="domain_force">[('create_uid','=',user.id)]</field>
</record>

<record id="stock_picking_user_rule" model="ir.rule">
    <field name="name">User Own Pickings</field>
    <field name="model_id" ref="stock.model_stock_picking"/>
    <field name="groups" eval="[(4, ref('stock.group_stock_user'))]"/>
    <field name="domain_force">[('create_uid','=',user.id)]</field>
</record>
üëâ With this, you don‚Äôt need Python filtering ‚Äì Odoo automatically restricts.

‚öñÔ∏è Which should you use?

If this restriction is only for your custom dashboard, go with Python filtering (Option 1).

If this restriction should apply system-wide (in tree views, kanban, etc.), go with Record Rules (Option 2).

Do you want me to apply restriction only in your dashboard (Python) or globally in Odoo (record rules)?




No file chosenNo file chosen
ChatGPT can make mistakes. Check important info. See Cookie Preferences.
